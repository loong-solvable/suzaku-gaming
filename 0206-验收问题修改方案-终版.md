# 海战CPS公会数据系统 — 0206验收问题修改方案（终版）

> **生成日期**: 2026-02-06  
> **项目**: suzaku-gaming（海战CPS公会数据/绑定系统）  
> **范围**: 7项验收问题 + 2项新增需求 + 风险修补  
> **状态**: 待实施  
> **基线版本**: main 分支当前 HEAD

---

## 0. 使用说明

- 本文档融合两份前序方案优点，经两轮代码核查修正了全部已知风险。
- 所有代码引用均已与仓库当前源码核实，标注了文件名和行号。
- 每个 Phase 设有**硬闸门**：该阶段全部测试通过后方可进入下一阶段。
- 阶段内测试覆盖 4 层：数据库层 → 服务层 → 接口层 → 前端层。

---

## 1. 风险登记表

### 1.1 已识别风险（R1-R12）

| # | 风险描述 | 严重度 | 证据 | 本方案处理策略 |
|---|---------|--------|------|---------------|
| R1 | 前端若使用 `cpsGroupName`/`memberCode` 新字段名发请求，`ValidationPipe({ forbidNonWhitelisted: true })` 拒绝 | **阻断** | `main.ts:24-27`、`create-binding-apply.dto.ts` | 继续使用 `platform`/`teamMember` 字段名，仅改语义值 |
| R2 | Manager 数据隔离依赖 `teamLeader: username`，置空后 Manager 看不到本组申请 | **阻断** | `audit.service.ts:62-63` | Manager 隔离改为 `platform = cpsGroupCode`，兼容旧 `teamLeader`；**全链路**（list/detail/update/review/export）统一修改 |
| R3 | `count+1` 编号算法存在并发重复风险 | 高 | 前序方案伪代码 | `MAX(memberCode) + 1` + `@@unique([cpsGroupCode, memberCode])` + 事务 + 冲突重试（最多 3 次，捕获 Prisma `P2002` / PostgreSQL `23505`） |
| R4 | 同步 SQL 移除 `total_recharge_usd` 后 `upsertRoles()` 将该字段归零 | 高 | `thinkingdata.service.ts:694` | 保留同步写入，仅在展示层改为订单聚合 |
| R5 | `getRoles()` 逐角色 `include orders` 引发 N+1 | 高 | `player.service.ts:129-157` | Prisma `groupBy` 单次聚合当前页角色 |
| R6 | 改动 `cps.service.ts` → `checkBinding()` 破坏 CPS 模块已有语义 | 高 | `cps.service.ts:110` | 不改 `cps.service.ts`；在 `audit.service.ts` 新增独立校验 |
| R7 | `prisma migrate rollback` 不是有效命令 | 中 | Prisma 官方文档 | 回滚 = `pg_dump` 全量备份恢复 + 前向修复 SQL |
| R8 | 历史可见性回填按 `cps_group IS NOT NULL` 不准确 | 中 | `audit.service.ts:251` | 基于 `binding_applies WHERE status='approved'`；处理多条审核、旧 `platform` 语义 |
| R9 | 更新接口 `@Body() dto: Partial<CreateBindingApplyDto>` 无运行时校验（TypeScript `Partial` 非 class-validator 类） | **阻断** | `audit.controller.ts:84` | 新建 `UpdateBindingApplyDto`（`PartialType(CreateBindingApplyDto)`），强制 `project`/`attachments` 同规则 |
| R10 | 审核接口无组权限校验：Manager 可审核任意组申请 | **阻断** | `audit.controller.ts:105`、`audit.service.ts:251` | `reviewBindingApply` 增加组权限前置校验 |
| R11 | 同一 `roleId` 可重复提交多条 pending 申请，审批时互相覆盖 | **阻断** | `schema.prisma:200`（`BindingApply` 无唯一约束） | **数据库层**：添加 PostgreSQL 部分唯一索引 `CREATE UNIQUE INDEX ... WHERE status IN ('pending','approved')`；**应用层**：`findFirst` 兜底提示 |
| R12 | 审核通过但角色更新失败时静默吞异常，导致"申请已通过但角色不可见" | **阻断** | 前版方案 try/catch 设计 | 角色更新失败时**事务回滚**，拒绝通过审核 |

### 1.2 补充风险

| # | 风险描述 | 严重度 | 处理策略 |
|---|---------|--------|---------|
| R13 | 前端 `type-check` 基线不干净，Phase 0 闸门不可信 | **阻断前置** | 先修复前端 TS 编译错误再进入业务改造 |
| R14 | `tf_medium` 过滤可能遗漏大小写不一致的值 | 中 | SQL 过滤使用 `ILIKE`（PostgreSQL 大小写无关匹配） |
| R15 | 编号上限 `A-999` 后字符串排序取错最大值 | 中 | 统一使用 **4 位固定填充**（`A-0001` ~ `A-9999`），避免混合位宽排序错误；9999 上限足够 |
| R16 | 服务端未校验 `platform`/`teamMember` 的业务合法性（可伪造组名/编号） | 高 | 创建/更新申请时服务端强校验：`platform` 必须是已存在的 `cpsGroupCode`，`teamMember` 必须是该组已有 `memberCode` |
| R17 | E2E 测试仅覆盖"页面存在性"，不保障业务正确性 | 中 | 升级闸门为 API 集成测试；E2E 作为补充 |
| R18 | `getTeamOptions` 返回结构从 `managers/operators` 改为 `groups/members` 会导致 Phase 1~4 间前端运行时错误 | **阻断** | `NewAttribution.vue:25-27` 读取 `res.managers`/`res.operators` | Phase 1 返回**同时包含新旧 key**（向后兼容），Phase 4 前端切换后移除旧 key |
| R19 | 审核事务更新条件仅用 `id`，并发审核可双双通过 | **阻断** | 审核 `tx.bindingApply.update({ where: { id } })` | 改用 `updateMany({ where: { id, status: 'pending' } })` + 校验 `count === 0` 回滚 |
| R20 | `@nestjs/mapped-types` 未安装，`UpdateBindingApplyDto` 首轮编译失败 | **阻断** | `package.json` 无此依赖 | 改用已安装的 `@nestjs/swagger` 导出的 `PartialType`/`OmitType` |
| R21 | `platform`/`teamMember` 在 DTO 中仍为 `@IsOptional`，后端不强制必填 | 高 | `create-binding-apply.dto.ts:31,41` | 服务层 `createBindingApply` 增加非空前置校验（DTO 层推迟到 Phase 4 同步改，避免中间阶段前端断裂） |
| R22 | 仓库当前缺少 `jest-e2e.json`，API 集成测试基础设施缺失 | 中 | `package.json:20` 引用但文件不存在 | Phase 0 增加"创建测试基础设施"步骤 |

---

## 2. 问题清单与解决方案

### 2.1 P1：角色列表金额不准确（高）

**问题**：角色列表"总付费金额"应使用订单事件明细 `pay_amount_usd` 聚合值，而非 ThinkingData 的 `total_recharge_usd`。

**根因**：`thinkingdata.service.ts:559` 拉取 `total_recharge_usd`；`player.service.ts:164` 直接读取展示。

**方案**：
1. **同步层不改写入**（R4）——`total_recharge_usd` 保留在同步 SQL 和 `upsertRoles` 中正常写入角色表，作参考值。
2. **展示层改为聚合**（R5）——`getRoles()` 金额改为 Prisma `order.groupBy({ by: ['roleId'], _sum: { payAmountUsd: true } })`，对当前页角色 ID 单次聚合。
3. **导出对齐**——`exportRoles()` 使用相同聚合口径。

---

### 2.2 P2：保持现状（冻结）

**处理**：不修改。每个 Phase 结束时执行防回归测试。

---

### 2.3 P3：归因绑定缺少绑定判断（高）

**方案**：由 N2 统一解决——
1. 同步阶段增加 `tf_medium` 过滤（使用 `ILIKE` 避免 R14），仅候选角色入库。
2. 归因申请创建前，`audit.service.ts` **新增** `validateRoleForBinding()` 校验角色存在于本地库且**可绑定**（无 pending 或 approved 的申请、未设 cpsGroup）。
3. 校验失败记录至 `cps_bind_fail_logs`。
4. **不改动 `cps.service.ts`**（R6）。

**历史数据处理**：对已入库的非候选角色（历史买量数据），通过 `cpsVisible = false`（默认值）自然隔离，无需删除。

---

### 2.4 P4：归因表单三级改二级（高）

**方案**：
1. 前端改为两级：组名 + 组员编号。
2. **继续使用 `platform`/`teamMember` 字段名**（R1）。`platform` 存 CPS 组编码，`teamMember` 存组员编号。
3. `teamLeader` 前端不传，**后端自动回填**（R2）。
4. **服务端强校验**（R16）：`platform` 必须是已存在的 `cpsGroupCode`，`teamMember` 必须是该组已有的 `memberCode`。
5. Manager/Operator 只能提交本组申请（后端校验 `platform` 与当前用户 `cpsGroupCode` 一致，Admin 无限制）。

---

### 2.5 P5：截图上传必选 3-5 张（中）

**方案**：
1. **前端**：提交前校验成功上传数 `3 ≤ n ≤ 5`。
2. **后端创建 DTO**：`attachments` 移除 `@IsOptional()`，增加 `@IsArray()` + `@ArrayMinSize(3)` + `@ArrayMaxSize(5)` + `@IsString({ each: true })`。
3. **新建 `UpdateBindingApplyDto`**（R9）：使用 `PartialType(CreateBindingApplyDto)`（来自 `@nestjs/swagger`，R20），覆盖 `attachments` 保持同规则——若传了 `attachments`，仍必须 3-5 张。
4. **编辑场景**同规则。

---

### 2.6 P6：项目固定为"海战"（中）

**方案**：
1. 前端：标签改为"项目"，只读显示"海战"。
2. **后端创建时**：`createBindingApply()` 强制 `project = 'warship'`。
3. **后端更新时**：`updateBindingApply()` 强制 `project = 'warship'` 或禁止修改 `project` 字段。

---

### 2.7 P7：列表仅展示已归因角色（高）

**方案**：由 N2 解决——
1. 角色表新增 `cpsVisible`（默认 `false`）。
2. 审核通过时**在事务内**更新角色 `cpsVisible = true`。若角色更新失败，**事务回滚**，审核不通过（R12）。
3. 列表/导出查询统一增加 `cpsVisible = true`。

---

## 3. 新增需求方案

### 3.1 N1：用户管理与组织架构

**Seed 环境区分**（审阅意见第 3 点第 2 条）：

```typescript
// seed.ts 开头增加环境保护
if (process.env.NODE_ENV === 'production') {
  console.log('⚠️ 生产环境：仅执行 upsert 账户，跳过示例数据');
}
// 所有账户使用 upsert（幂等）
// 示例业务数据（角色/订单/申请）仅在非生产环境创建
```

**组员编号算法**（R3 + R15 完整方案）：

```typescript
async generateMemberCode(cpsGroupCode: string): Promise<string> {
  const prefix = cpsGroupCode.replace('Group', ''); // 'GroupA' → 'A'

  // R15 修正：使用原始 SQL 按数值排序取最大值，避免字符串排序错误
  const result = await this.prisma.$queryRaw<{ max_seq: number }[]>`
    SELECT COALESCE(
      MAX(CAST(SPLIT_PART(member_code, '-', 2) AS INTEGER)),
      0
    ) AS max_seq
    FROM admin_users
    WHERE cps_group_code = ${cpsGroupCode}
      AND member_code IS NOT NULL
      AND role = 'operator'
  `;

  const nextSeq = (result[0]?.max_seq || 0) + 1;

  // 固定 4 位填充（A-0001 ~ A-9999），字符串排序安全
  return `${prefix}-${String(nextSeq).padStart(4, '0')}`;
}
```

**并发安全**：
- 依赖 `@@unique([cpsGroupCode, memberCode])` 数据库约束。
- `createUser` 方法中捕获 Prisma 异常码 **`P2002`**（对应 PostgreSQL `23505` unique_violation），最多重试 3 次。
- 每次重试重新执行 `MAX(CAST(...))` 查询确保取到最新值。
- 编号统一 4 位填充（`A-0001` ~ `A-9999`），字符串排序结果与数值排序一致。

---

### 3.2 N2：业务流程全链路调整

**关键补充**：

#### 3.2.1 审核权限隔离（R10）

当前 `reviewBindingApply` 仅传 `reviewerId`，无组权限校验。修改为：

```typescript
async reviewBindingApply(
  id: number,
  dto: ReviewBindingApplyDto,
  currentUser: CurrentUser,  // 改传完整用户对象
) {
  const apply = await this.prisma.bindingApply.findUnique({ where: { id } });
  if (!apply) throw new NotFoundException('绑定申请不存在');
  if (apply.status !== 'pending') throw new BadRequestException('该申请已被审核');

  // 权限校验：Manager 只能审核本组申请
  if (currentUser.level === 1) {
    if (apply.platform !== currentUser.cpsGroupCode
        && apply.teamLeader !== currentUser.username) { // 兼容旧数据
      throw new ForbiddenException('无权审核非本组的申请');
    }
  }
  // Admin (level=0) 无限制
  // Operator 无审核权限（已由 @Roles 守卫拦截）
  // ...
}
```

对应 `audit.controller.ts:105` 改为传完整 `(req as any).user`。

#### 3.2.2 防重复提交（R11——数据库层 + 应用层双保险）

**数据库层**：Phase 1 Schema 变更时，通过 `prisma db push` 后额外执行原始 SQL 创建部分唯一索引：

```sql
-- 防止同一 roleId 同时存在多条 pending 或 approved 的申请
CREATE UNIQUE INDEX IF NOT EXISTS binding_apply_role_active_unique
  ON binding_applies (role_id)
  WHERE status IN ('pending', 'approved');
```

> Prisma 不原生支持部分唯一索引，需通过 `prisma.$executeRaw` 在 Phase 1 的迁移步骤中执行。

**应用层**：兜底校验 + 友好错误提示：

```typescript
// createBindingApply 中
const pendingExists = await this.prisma.bindingApply.findFirst({
  where: {
    roleId: dto.roleId,
    status: { in: ['pending', 'approved'] },
  },
});
if (pendingExists) {
  const statusText = pendingExists.status === 'pending' ? '待审核' : '已通过';
  throw new BadRequestException(
    `该角色已有${statusText}的绑定申请（ID: ${pendingExists.id}），不可重复提交`
  );
}
// 即使应用层检查被并发穿透，数据库唯一索引仍会拒绝写入
```

#### 3.2.3 审核通过联动—不吞异常（R12）

```typescript
return this.prisma.$transaction(async (tx) => {
  // R19 原子更新：WHERE 条件包含 status='pending'，防止并发双通过
  const updateResult = await tx.bindingApply.updateMany({
    where: { id, status: 'pending' },  // ← 原子条件
    data: {
      status: newStatus,
      reviewTime: new Date(),
      reviewerId: currentUser.id,
      remark: dto.remark || apply.remark,
    },
  });

  // 校验影响行数：为 0 说明已被其他审核员处理
  if (updateResult.count === 0) {
    throw new BadRequestException('该申请已被其他审核员处理，请刷新页面后重试');
  }

  if (dto.action === 'approve') {
    // 角色更新——不 try/catch，失败直接事务回滚（R12）
    const role = await tx.role.findUnique({ where: { roleId: apply.roleId } });
    if (!role) {
      throw new BadRequestException(`审核失败：角色 ${apply.roleId} 不存在于本地数据库`);
    }
    await tx.role.update({
      where: { roleId: apply.roleId },
      data: {
        cpsVisible: true,
        cpsGroup: apply.platform,
        cpsBindTime: new Date(),
        cpsBindBy: currentUser.id,
      },
    });
  }

  // 审计日志
  await tx.auditLog.create({ data: { /* ... */ } });

  // updateMany 不返回记录，需重新查询返回
  return tx.bindingApply.findUnique({ where: { id } });
});
```

---

## 4. 全链路权限隔离改造（R2 完整方案）

前版仅改 `buildDataFilter`，审阅发现 `getBindingApplyById`（`audit.service.ts:177`）和 `updateBindingApply`（`audit.service.ts:222`）同样依赖 `teamLeader`。本节统一规划。

### 4.1 统一隔离辅助方法

```typescript
/**
 * 判断 Manager 是否有权"查看/编辑"指定申请
 * 同时兼容新数据（platform = cpsGroupCode）和旧数据（teamLeader = username）
 * 注意：此方法包含 applicant 自身查看权限，仅用于查看/编辑，不可用于审核
 */
private canManagerView(apply: { platform?: string; teamLeader?: string; applicant: string }, currentUser: CurrentUser): boolean {
  return (
    apply.platform === currentUser.cpsGroupCode ||   // 新数据：组编码匹配
    apply.teamLeader === currentUser.username ||      // 旧数据：组长名匹配
    apply.applicant === currentUser.username           // 自己提交的（仅查看/编辑需要）
  );
}

/**
 * 判断 Manager 是否有权"审核"指定申请（R10）
 * ★ 不包含 applicant 条件——防止"非本组但本人申请可审核"的语义漏洞
 * 审核权限严格按组归属判定
 */
private canManagerReview(apply: { platform?: string; teamLeader?: string }, currentUser: CurrentUser): boolean {
  return (
    apply.platform === currentUser.cpsGroupCode ||   // 新数据：组编码匹配
    apply.teamLeader === currentUser.username          // 旧数据：组长名匹配
  );
}
```

### 4.2 需改动的 5 个位置

| 位置 | 现状 | 改为 |
|------|------|------|
| `buildDataFilter`（列表）L62 | `teamLeader: username` | `OR: [ { platform: cpsGroupCode }, { teamLeader: username }, { applicant: username } ]` |
| `getBindingApplyById`（详情）L177-178 | `teamLeader !== username && applicant !== username` | 调用 `canManagerView()` |
| `updateBindingApply`（编辑）L222-223 | `teamLeader !== username && applicant !== username` | 调用 `canManagerView()` |
| `reviewBindingApply`（审核）L251+ | 无组权限校验 | 增加 **`canManagerReview()`** 前置检查（Admin 跳过）—— ★注意与查看/编辑使用不同方法 |
| `exportBindingApplies`（导出）L305+ | 使用 `buildDataFilter` | 自动跟随修复 |

---

## 5. 更新接口 DTO 改造（R9）

### 5.1 问题

当前更新接口签名：

```typescript
// audit.controller.ts:84
@Body() dto: Partial<CreateBindingApplyDto>
```

`Partial<T>` 是 TypeScript 类型工具，不是 class-validator 能识别的类。运行时 `ValidationPipe` 无法应用 `CreateBindingApplyDto` 上的装饰器。结果：更新接口**无任何校验**，可绕过截图数量限制、项目固定等规则。

### 5.2 方案

新建 `UpdateBindingApplyDto`：

```typescript
// src/modules/audit/dto/update-binding-apply.dto.ts
// R20: 使用已安装的 @nestjs/swagger（而非未安装的 @nestjs/mapped-types）
import { PartialType, OmitType } from '@nestjs/swagger';
import { IsArray, ArrayMinSize, ArrayMaxSize, IsString, IsOptional } from 'class-validator';
import { CreateBindingApplyDto } from './create-binding-apply.dto';

export class UpdateBindingApplyDto extends PartialType(
  OmitType(CreateBindingApplyDto, ['project', 'applicant'] as const) // 禁止修改项目和申请人
) {
  @IsOptional()
  @IsArray()
  @ArrayMinSize(3, { message: '至少需要上传3张截图' })
  @ArrayMaxSize(5, { message: '最多上传5张截图' })
  @IsString({ each: true, message: '每个附件必须是字符串URL' })
  attachments?: string[];  // 若传了 attachments，仍必须 3-5 张
}
```

`audit.controller.ts:84` 改为：

```typescript
@Body() dto: UpdateBindingApplyDto
```

`audit.service.ts → updateBindingApply` 增加：

```typescript
// 强制项目不可改
if ('project' in dto) { delete (dto as any).project; }
// 强制服务端覆盖 project（以防万一）
await tx.bindingApply.update({
  where: { id },
  data: { ...dto, project: 'warship' },
});
```

---

## 6. 数据模型变更汇总

```prisma
model AdminUser {
  // 现有字段保留 ...
  memberCode   String?   @map("member_code") @db.VarChar(20)
  // 新增唯一约束
  @@unique([cpsGroupCode, memberCode], name: "group_member_unique")
}

model Role {
  // 现有字段保留 ...
  cpsVisible   Boolean   @default(false) @map("cps_visible")
  // 新增索引
  @@index([cpsVisible])
}
```

`BindingApply` 表**不改 Schema**——复用 `platform`/`teamLeader`/`teamMember`，仅改语义。防重采用**数据库 + 应用双层策略**：1) 数据库层通过部分唯一索引 `binding_apply_role_active_unique`（`role_id WHERE status IN ('pending','approved')`）硬约束唯一性；2) 应用层在 `createBindingApply` 中先 `findFirst` 检查并返回友好提示，作为用户体验层兜底。

---

## 7. 创建申请服务端强校验完整流程（R16 + R11 + R12 + P3 + P5 + P6）

```typescript
async createBindingApply(dto: CreateBindingApplyDto, currentUser: CurrentUser) {
  // 1. 校验角色可绑定性（P3）
  const role = await this.prisma.role.findUnique({
    where: { roleId: dto.roleId },
    select: { roleId: true, roleName: true, serverId: true, serverName: true, cpsGroup: true, cpsVisible: true },
  });
  if (!role) {
    await this.logBindFail(dto.roleId, currentUser.id, '该角色不在CPS候选池中，无法绑定');
    throw new BadRequestException('该角色不在CPS候选池中，无法绑定');
  }
  if (role.cpsGroup || role.cpsVisible) {
    await this.logBindFail(dto.roleId, currentUser.id, `该角色已绑定到分组: ${role.cpsGroup}`);
    throw new BadRequestException(`该角色已绑定到分组: ${role.cpsGroup}`);
  }

  // 2. 防重复提交（R11）
  const existingApply = await this.prisma.bindingApply.findFirst({
    where: { roleId: dto.roleId, status: { in: ['pending', 'approved'] } },
  });
  if (existingApply) {
    const statusText = existingApply.status === 'pending' ? '待审核' : '已通过';
    throw new BadRequestException(`该角色已有${statusText}的绑定申请（ID: ${existingApply.id}），不可重复提交`);
  }

  // 3. R21 服务层强制必填（DTO 层 @IsOptional 保留到 Phase 4 前端同步切换后再改）
  if (!dto.platform) {
    throw new BadRequestException('组名（platform）为必填项');
  }
  if (!dto.teamMember) {
    throw new BadRequestException('组员编号（teamMember）为必填项');
  }

  // 4. 校验 platform 是合法的 cpsGroupCode（R16）
  //    ★ Phase 3~4 过渡兼容：旧前端 platform 可能传旧语义值（google/facebook/...）
  //    此时 Phase 4 尚未上线，需同时接受旧值（任意非空字符串）和新值（GroupA/B/C）
  //    判定策略：先查 cpsGroupCode 匹配；若不匹配，降级检查当前用户是否有组编码
  const groupExists = await this.prisma.adminUser.findFirst({
    where: { cpsGroupCode: dto.platform, role: 'manager', status: 1 },
  });

  let effectivePlatform = dto.platform;     // 实际存储值
  let effectiveGroupCode = dto.platform;    // 用于后续 memberCode 校验

  if (!groupExists) {
    // 旧前端提交旧语义：退回到当前用户自身的 cpsGroupCode
    if (currentUser.cpsGroupCode) {
      effectivePlatform = dto.platform;       // 保留原值写入（旧语义）
      effectiveGroupCode = currentUser.cpsGroupCode; // 校验 memberCode 时用用户真实组
    } else if (currentUser.level !== 0) {
      throw new BadRequestException(`无效的CPS分组编码: ${dto.platform}`);
    }
    // admin 不强制校验组编码
  }

  // 非 admin 只能提交本组申请（仅在 platform 为新语义时判断）
  if (groupExists && currentUser.level !== 0 && dto.platform !== currentUser.cpsGroupCode) {
    throw new ForbiddenException('不允许为其他分组提交申请');
  }

  // 5. 校验 teamMember 是合法的 memberCode（R16）
  //    ★ Phase 3~4 过渡兼容：旧前端 teamMember 传的是 username 而非 memberCode
  //    判定策略：先按 memberCode 查；查不到再按 username 查
  let memberExists = await this.prisma.adminUser.findFirst({
    where: { cpsGroupCode: effectiveGroupCode, memberCode: dto.teamMember, role: 'operator', status: 1 },
  });
  if (!memberExists) {
    // 降级：旧前端提交 username
    memberExists = await this.prisma.adminUser.findFirst({
      where: { cpsGroupCode: effectiveGroupCode, username: dto.teamMember, role: 'operator', status: 1 },
    });
  }
  if (!memberExists && currentUser.level !== 0) {
    throw new BadRequestException(`分组 ${effectiveGroupCode} 中不存在组员编号或用户名: ${dto.teamMember}`);
  }

  // 6. 自动回填 teamLeader（R2）
  let teamLeader: string | null = null;
  if (dto.platform) {
    const leader = await this.prisma.adminUser.findFirst({
      where: { cpsGroupCode: dto.platform, role: 'manager', status: 1 },
      select: { username: true },
    });
    teamLeader = leader?.username || null;
  }

  // 7. 创建（R11：捕获数据库唯一索引冲突，返回友好 4xx 而非 500）
  try {
    return await this.prisma.bindingApply.create({
      data: {
        ...dto,
        project: 'warship',                                // P6 强制
        applicant: currentUser.username,                    // 强制申请人
        teamLeader,                                         // R2 自动回填
        attachments: dto.attachments,                       // DTO 已校验 3-5（P5）
        status: 'pending',
      },
    });
  } catch (error) {
    // Prisma P2002 = PostgreSQL 23505 unique_violation
    // 当 findFirst 预检查与 create 之间有并发写入时触发
    if (error?.code === 'P2002') {
      throw new ConflictException('该角色已有待审核或已通过的绑定申请，请勿重复提交');
    }
    throw error; // 其他异常原样抛出
  }
}

private async logBindFail(roleId: string, operatorId: number, failReason: string) {
  await this.prisma.cpsBindFailLog.create({
    data: { roleId, operatorId, failReason },
  });
}
```

---

## 8. 实施阶段规划

### Phase 0：基线稳定化（阻断前置项）

**目标**：消除已知编译错误，建立可信闸门基线。

#### 0.1 具体步骤

| # | 操作 | 命令/文件 |
|---|------|----------|
| 0.1 | 修复前端 TypeScript 编译错误（路由类型、重复导出、测试类型不匹配等） | 逐个修复，直到 `pnpm -C suzaku-gaming-admin type-check` 通过 |
| 0.2 | 确认后端构建正常 | `pnpm -C suzaku-gaming-server build` |
| 0.3 | **R22 创建后端测试基础设施** | 创建 `suzaku-gaming-server/test/jest-e2e.json`、编写 API 集成测试 bootstrap（`test/app.e2e-spec.ts`） |
| 0.4 | 建立 P2 冻结基线快照 | 记录订单列表充值渠道当前显示行为 |
| 0.5 | 数据库全量备份 | `pg_dump -Fc -f backup_phase0.dump` |

#### 0.2 闸门

| 编号 | 测试 | 通过标准 |
|------|------|---------|
| T0.1 | `pnpm -C suzaku-gaming-admin type-check` | 0 error（允许 warning） |
| T0.2 | `pnpm -C suzaku-gaming-server build` | 0 error |
| T0.3 | `pnpm -C suzaku-gaming-server test:e2e` | 测试通过（步骤 0.3 创建的基础测试） |
| T0.4 | 现有登录/列表/权限手动验证 | 基本功能正常 |

**Phase 0 通过后方可进入 Phase 1。**

---

### Phase 1：Schema + Seed + 用户管理 + DTO 改造

**目标**：完成数据模型变更、初始化 A/B/C 组长、实现组员编号自动生成、新建 `UpdateBindingApplyDto`。

#### 1.1 变更清单

| 文件 | 变更 |
|------|------|
| `prisma/schema.prisma` | AdminUser 加 `memberCode` + `@@unique([cpsGroupCode, memberCode])`；Role 加 `cpsVisible` + `@@index([cpsVisible])` |
| `prisma/seed.ts` | 改为 admin + 3 组长（upsert 幂等）；**生产环境保护**；移除示例业务数据 |
| `src/modules/user/user.service.ts` | `createUser()` 增加编号生成（含并发重试）；`getTeamOptions(currentUser)` 增加 `memberCode`/`cpsGroupCode` 返回 + 数据隔离 + **向后兼容旧 key** |
| `src/modules/user/user.controller.ts` | `getTeamOptions()` 增加 `@Req() req` 传 `currentUser` |
| `src/modules/audit/dto/update-binding-apply.dto.ts` | **新建**：`PartialType(OmitType(...))`，使用 `@nestjs/swagger` 导入（R20） |
| `src/modules/audit/audit.controller.ts` L84 | 更新接口 DTO 改为 `UpdateBindingApplyDto` |
| 迁移脚本（`prisma db push` 后执行） | 添加 `binding_applies` 部分唯一索引（R11） |
| 前端 `UserManagement.vue` | 表格增加"组员编号"列 |
| 前端 `src/api/user.ts` | `getTeamOptions` 返回类型更新（新增 `groups`/`members` 字段，保留 `managers`/`operators`） |

#### 1.2 Seed 设计

```typescript
const accounts = [
  { username: 'admin',    role: 'admin',   level: 0, cpsGroupCode: null,     realName: '系统管理员' },
  { username: 'leader_a', role: 'manager', level: 1, cpsGroupCode: 'GroupA', realName: 'A组组长' },
  { username: 'leader_b', role: 'manager', level: 1, cpsGroupCode: 'GroupB', realName: 'B组组长' },
  { username: 'leader_c', role: 'manager', level: 1, cpsGroupCode: 'GroupC', realName: 'C组组长' },
];
// 全部使用 upsert，幂等安全
// 示例业务数据仅 NODE_ENV !== 'production' 时创建
```

#### 1.3 部分唯一索引（R11 数据库层防重）

Schema 变更（`prisma db push`）完成后，按以下顺序执行原始 SQL：

> **⚠ 迁移窗口要求**：步骤 A 和步骤 B 必须在**维护窗口内连续执行**，期间暂停对 `binding_applies` 的写入（即暂停前端归因申请和审核操作）。推荐做法：
> 1. 维护前通知使用者暂停操作（预计 5 分钟）
> 2. 在步骤 A 之前先执行 `pg_dump -Fc -t binding_applies -f backup_binding_applies.dump` 单表备份
> 3. 连续执行步骤 A → 步骤 B
> 4. 验证索引存在后恢复服务
>
> 若步骤 B 仍因残留重复而失败，用备份恢复后重新排查去重 SQL。

**步骤 A：检查并清理历史重复数据**（防止 `CREATE UNIQUE INDEX` 失败）：

```sql
-- 1. 查找重复（同 role_id 存在多条 pending/approved）
SELECT role_id, COUNT(*) AS cnt
FROM binding_applies
WHERE status IN ('pending', 'approved')
GROUP BY role_id
HAVING COUNT(*) > 1;

-- 2. 若有重复，优先保留 approved（保障后续可见性回填依赖），
--    同状态下按 review_time/apply_time 取最新；其余降为 rejected
UPDATE binding_applies ba
SET status = 'rejected',
    remark = COALESCE(remark, '') || ' [系统去重: 迁移清理]'
WHERE ba.id NOT IN (
  SELECT DISTINCT ON (role_id) id
  FROM binding_applies
  WHERE status IN ('pending', 'approved')
  ORDER BY role_id,
    -- approved 优先于 pending（保证回填 SQL 的 status='approved' 条件不被破坏）
    CASE status WHEN 'approved' THEN 0 ELSE 1 END ASC,
    -- 同状态按最新时间
    COALESCE(review_time, apply_time) DESC NULLS LAST
)
AND ba.status IN ('pending', 'approved');
```

**步骤 B：创建部分唯一索引**：

```sql
CREATE UNIQUE INDEX IF NOT EXISTS binding_apply_role_active_unique
  ON binding_applies (role_id)
  WHERE status IN ('pending', 'approved');
```

> Prisma 不原生支持 `WHERE` 过滤的部分唯一索引，需通过 `prisma.$executeRaw` 或数据库客户端手动执行。此索引确保同一 `roleId` 在 `pending`/`approved` 状态下最多存在一条记录。

#### 1.4 `getTeamOptions` 改造

```typescript
// user.controller.ts
async getTeamOptions(@Req() req: Request) {
  return this.userService.getTeamOptions((req as any).user);
}

// user.service.ts
async getTeamOptions(currentUser?: CurrentUser) {
  // 基础查询
  let groupFilter: any = { role: 'manager', status: 1 };
  let memberFilter: any = { role: 'operator', status: 1 };

  // 非 admin 仅返回本组数据
  if (currentUser && currentUser.level !== 0) {
    if (!currentUser.cpsGroupCode) {
      // 无组编码的非 admin 用户：返回空集，防止 fail-open 泄露全量数据
      return { managers: [], operators: [], groups: [], members: [] };
    }
    groupFilter.cpsGroupCode = currentUser.cpsGroupCode;
    memberFilter.cpsGroupCode = currentUser.cpsGroupCode;
  }

  const [groups, members] = await Promise.all([
    this.prisma.adminUser.findMany({
      where: groupFilter,
      select: { id: true, username: true, realName: true, cpsGroupCode: true },
      orderBy: { cpsGroupCode: 'asc' },
    }),
    this.prisma.adminUser.findMany({
      where: memberFilter,
      // R18 兼容：保留 parentId，旧前端 NewAttribution.vue:87 依赖此字段过滤组员
      // Phase 4 新页面改用 cpsGroupCode 过滤后，可移除 parentId
      select: { id: true, username: true, realName: true, cpsGroupCode: true, memberCode: true, parentId: true },
      orderBy: { memberCode: 'asc' },
    }),
  ]);

  // R18 向后兼容：同时返回旧 key（managers/operators）和新 key（groups/members）
  // Phase 1~3 期间前端仍读取 managers/operators（NewAttribution.vue:25-27）
  // Phase 4 前端切换到 groups/members 后，可移除旧 key
  return {
    managers: groups,    // 旧 key——向后兼容
    operators: members,  // 旧 key——向后兼容
    groups,              // 新 key——Phase 4 前端使用
    members,             // 新 key——Phase 4 前端使用
  };
}
```

#### 1.4 闸门

| 编号 | 测试 | 操作 | 预期 |
|------|------|------|------|
| T1.1 | Schema 同步 | `cd suzaku-gaming-server && npx prisma db push` | 无报错 |
| T1.2 | 后端构建 | `pnpm -C suzaku-gaming-server build` | 0 error |
| T1.3 | Seed 幂等 | `cd suzaku-gaming-server && npx prisma db seed` 执行 2 次 | 无报错、不重复 |
| T1.4 | 初始账户 | 查 `admin_users` | admin + leader_a/b/c |
| T1.5 | 组长创建组员 | leader_a `POST /api/user/create` | 成功，返回 `memberCode` 格式为 `A-XXXX`（4 位数字） |
| T1.6 | 编号递增 | leader_a 再创建 | `memberCode` 序号比 T1.5 结果 +1 |
| T1.7 | 跨组独立 | leader_b 创建 | 返回 `B-XXXX`，序号独立于 A 组 |
| T1.8 | 唯一约束 | 手动 SQL 插入重复 `(cps_group_code, member_code)` 值 | 数据库拒绝 |
| T1.9 | **并发压测** | 同时 5 个请求创建 A 组组员 | 5 个编号**各不相同**、格式均为 `A-XXXX`、序号连续递增，无重复无间隙 |

> **T1.5~T1.9 适配说明**：断言不依赖固定编号值（如 `A-0001`），而是验证格式、递增、唯一性。这样在已有历史数据的环境中也能正确通过。
| T1.10 | 部分唯一索引 | `SELECT indexname FROM pg_indexes WHERE tablename='binding_applies'` | 存在 `binding_apply_role_active_unique` |
| T1.11 | R11 索引生效 | 执行完整 SQL（见下方）插入 2 条同 roleId 的 pending 记录 | 第 2 条被唯一索引拒绝 |

> **T1.11 完整测试 SQL**：
> ```sql
> -- 第 1 条（应成功）
> INSERT INTO binding_applies (project, role_id, server_id, applicant, status, platform, apply_time, created_at, updated_at)
> VALUES ('warship', 'TEST_R11', 1, 'test_user', 'pending', 'GroupA', NOW(), NOW(), NOW());
> -- 第 2 条（应被唯一索引拒绝）
> INSERT INTO binding_applies (project, role_id, server_id, applicant, status, platform, apply_time, created_at, updated_at)
> VALUES ('warship', 'TEST_R11', 1, 'test_user2', 'pending', 'GroupA', NOW(), NOW(), NOW());
> -- 清理
> DELETE FROM binding_applies WHERE role_id = 'TEST_R11';
> ```
| T1.12 | 组长权限隔离 | leader_a 查用户列表 | 仅见本组 |
| T1.13 | 管理员全局 | admin 查列表 | 见所有 |
| T1.14 | `getTeamOptions`-admin | admin 调用 | 同时含 `managers`/`operators`（旧 key）和 `groups`/`members`（新 key） |
| T1.15 | `getTeamOptions`-leader | leader_a 调用 | 仅返回 A 组数据 |
| T1.16 | **R18 前端兼容** | 打开归因申请页面 | 组长/组员下拉正常加载（前端仍读 `managers`/`operators`） |
| T1.17 | 更新 DTO 编译 | `pnpm -C suzaku-gaming-server build` | `UpdateBindingApplyDto` 编译通过（使用 `@nestjs/swagger`） |
| T1.18 | 前端组员编号展示 | 打开用户管理 | 表格有"组员编号"列 |
| T1.19 | P2 冻结回归 | 订单列表充值渠道 | 与基线一致 |
| T1.20 | 前端构建 | `pnpm -C suzaku-gaming-admin type-check && pnpm -C suzaku-gaming-admin build` | 0 error |

---

### Phase 2：数据同步改造 + 金额口径修正（P1 + N2 同步部分）

**目标**：角色同步增加 `tf_medium` 过滤；新角色默认不可见；列表金额改为订单聚合。

#### 2.1 变更清单

| 文件 | 变更 |
|------|------|
| `src/modules/thinkingdata/thinkingdata.service.ts` | 3 个角色同步 SQL 增加 `tf_medium` ILIKE 条件；`upsertRoles()` 新角色设 `cpsVisible: false` |
| `src/modules/player/player.service.ts` | `getRoles()` 金额改为 `order.groupBy` 聚合；`exportRoles()` 同步对齐 |

#### 2.2 关键实现

**同步 SQL 变更**（3 处方法统一追加，R14 大小写无关）：

```sql
-- 在 WHERE "create_role_id" IS NOT NULL 后追加：
AND (
  "tf_medium" ILIKE 'Organic'
  OR "tf_medium" ILIKE '%自然量%'
  OR "tf_medium" ILIKE 'WA\_CPS\_link%'
)
```

> 涉及方法：`buildRoleSyncSQL`、`buildRoleSyncSQLNoLimit`、`buildRoleSyncSQLRange`

**`upsertRoles` 新角色处理**：

```diff
// upsert 的 create 对象中：
+ cpsVisible: false,    // 新角色默认不可见

// upsert 的 update 对象中：
// ⚠️ 不包含 cpsVisible，避免覆盖已审核通过的角色
```

**金额聚合**（R5 解决方案）：

```typescript
// player.service.ts → getRoles()
// 1. 查角色分页列表
const [list, total] = await Promise.all([...]);

// 2. 当前页角色 ID 单次聚合
const roleIds = list.map(r => r.roleId);
const amounts = await this.prisma.order.groupBy({
  by: ['roleId'],
  where: { roleId: { in: roleIds }, isSandbox: false },
  _sum: { payAmountUsd: true },
});
const amountMap = new Map(amounts.map(a => [a.roleId, Number(a._sum.payAmountUsd || 0)]));

// 3. 合并
return {
  list: list.map(role => ({
    ...role,
    totalRechargeUsd: amountMap.get(role.roleId) || 0,
  })),
};
```

#### 2.3 闸门

| 编号 | 测试 | 操作 | 预期 |
|------|------|------|------|
| T2.1 | SQL 生成验证 | 打印 3 个方法 SQL | 含 `tf_medium` ILIKE 过滤 |
| T2.2 | 新角色默认不可见 | 手动同步 | `cps_visible = false` |
| T2.3 | 已通过角色不被覆盖 | `cps_visible = true` 的角色再同步 | 仍 `true` |
| T2.4 | 金额聚合正确 | 角色 3 笔非沙盒订单 (1+2+3) | 返回 6.00 |
| T2.5 | 无订单角色 | 无订单 | 返回 0 |
| T2.6 | 仅沙盒订单 | 仅沙盒 | 返回 0 |
| T2.7 | 导出金额一致 | 导出 CSV | 金额与列表一致 |
| T2.8 | 同步参考值保留 | 同步后查 `total_recharge_usd` | 非 0 |
| T2.9 | 订单同步不受影响 | 执行订单同步 | 正常 |
| T2.10 | CPS 日志同步不受影响 | 执行 CPS 同步 | 正常 |
| T2.11 | **API 集成测试** | `GET /api/player/roles` 分页+金额 | 响应结构正确，金额为聚合值 |
| T2.12 | 后端构建 | `pnpm -C suzaku-gaming-server build` | 0 error |
| T2.13 | P2 冻结回归 | 订单列表充值渠道 | 与基线一致 |

---

### Phase 3：归因申请全链路改造（P3 + P5 + P6 + P7 + N2 后半 + R2/R9/R10/R11/R12/R16）

**目标**：归因申请创建/更新/审核全链路强校验；审核联动角色可见；列表/导出按可见性过滤；权限隔离全链路修复。

#### 3.1 变更清单

| 文件 | 变更 |
|------|------|
| `src/modules/audit/audit.service.ts` | 新增 `validateRoleForBinding()`、`canManagerView()`（查看/编辑权限）、`canManagerReview()`（审核权限，不含 applicant 条件）、`logBindFail()`；重构 `createBindingApply`（全校验链 + P2002 捕获）；重构 `updateBindingApply`（R9/R16）；重构 `reviewBindingApply`（R10/R12 用 `canManagerReview`）；重构 `buildDataFilter`/`getBindingApplyById`/`updateBindingApply` 权限判断（R2 用 `canManagerView`） |
| `src/modules/audit/audit.controller.ts` | `reviewBindingApply` 传完整 `currentUser`；更新接口 DTO 类型；新增 `GET role-check/:roleId` |
| `src/modules/audit/dto/create-binding-apply.dto.ts` | `attachments` 改必填 + `@ArrayMinSize(3)` + `@ArrayMaxSize(5)` + `@IsString({ each: true })` |
| `src/modules/audit/dto/update-binding-apply.dto.ts` | **新建** |
| `src/modules/player/player.service.ts` | `getRoles()`/`getOrders()`/`exportRoles()`/`exportOrders()` 增加 `cpsVisible: true` |

#### 3.2 全链路权限隔离改动矩阵

| 方法 | 现状 | 改为 |
|------|------|------|
| `buildDataFilter` L62 | `teamLeader: username` | `OR: [ platform: cpsGroupCode, teamLeader: username, applicant: username ]` |
| `getBindingApplyById` L177 | `teamLeader !== username && applicant !== username` | `canManagerView()`（含 applicant 自身查看） |
| `updateBindingApply` L222 | `teamLeader !== username && applicant !== username` | `canManagerView()` + 服务端强校验 `platform`/`teamMember` 合法性 |
| `reviewBindingApply` L251+ | 无组权限 | 新增 **`canManagerReview()`** 前置（★不含 applicant，严格按组归属）；审核通过事务内不吞异常 |
| `exportBindingApplies` L305 | 使用 `buildDataFilter` | 自动修复 |

#### 3.3 闸门

| 编号 | 测试 | 操作 | 预期 |
|------|------|------|------|
| **角色校验** | | | |
| T3.1 | 角色不存在 | `GET /api/audit/role-check/INVALID` | `{ valid: false }` |
| T3.2 | 角色存在未绑定 | `GET /api/audit/role-check/VALID` | `{ valid: true, role: {...} }` |
| T3.3 | 角色已绑定 | `GET /api/audit/role-check/BOUND` | `{ valid: false }` |
| **创建申请强校验** | | | |
| T3.4 | 无效角色ID | `POST /api/audit/binding-applies { roleId: 'INVALID' }` | 400 + 失败日志 |
| T3.5 | 重复提交同角色（应用层） | 已有 pending 申请，再提交 | 400 "已有待审核申请" |
| T3.5b | **R11 重复提交（并发/DB层）** | 2 个并发请求同时提交同角色 | 仅 1 条成功（201），另 1 条返回 **409**（`ConflictException`："该角色已有待审核或已通过的绑定申请"），不出现 500 |
| T3.5c | **R21 缺组名** | `POST` 不传 `platform` | 400 "组名为必填项" |
| T3.5d | **R21 缺编号** | `POST` 不传 `teamMember` | 400 "组员编号为必填项" |
| T3.6 | 伪造组名 | `platform: 'FakeGroup'` | 400 "无效CPS分组" |
| T3.7 | 伪造编号 | `platform: 'GroupA', teamMember: 'Z-999'` | 400 "不存在组员编号" |
| T3.8 | 跨组提交 | leader_a 提交 `platform: 'GroupB'` | 403 "不允许为其他分组提交" |
| T3.9 | 正常创建 | 合法数据 | 201 + `team_leader` 自动回填 |
| **截图校验** | | | |
| T3.10 | 创建 <3 张 | API 传 2 张附件 | 400 |
| T3.11 | 创建 >5 张 | API 传 6 张附件 | 400 |
| T3.12 | 更新 <3 张 | `PUT` 传 1 张附件 | 400 |
| T3.13 | 项目强制 | 创建传 `project: 'JUR'` | DB 存 `warship` |
| T3.14 | 更新禁改项目 | `PUT` 传 `project: 'JUR'` | DB 仍为 `warship` |
| **审核权限** | | | |
| T3.15 | Manager 审核本组 | leader_a 审核 A 组申请 | 成功 |
| T3.16 | Manager 跨组审核 | leader_a 审核 B 组申请 | 403 |
| T3.17 | Admin 审核任意 | admin 审核 B 组申请 | 成功 |
| **审核联动** | | | |
| T3.18 | 审核通过-角色可见 | approve | `cps_visible = true`，`cps_group` 设置 |
| T3.19 | 审核通过-角色不存在 | approve 但 roleId 已被删 | 400 事务回滚，申请状态不变（R12） |
| T3.20 | 审核拒绝 | reject | `cps_visible` 不变 |
| T3.20b | **R19 并发审核** | 2 个审核员同时 approve 同一申请 | 仅 1 人成功，另 1 人收到"已被处理"提示 |
| **列表过滤** | | | |
| T3.21 | 角色列表 | 无 approved 记录 | 列表空 |
| T3.22 | 角色列表 | 有 approved | 仅显示已通过 |
| T3.23 | 订单列表 | 过滤 | 仅显示已通过角色订单 |
| T3.24 | 导出角色 | CSV | 仅含已通过 |
| T3.25 | 导出订单 | CSV | 仅含已通过角色订单 |
| **权限隔离-全链路** | | | |
| T3.26 | Manager 列表 | leader_a 查申请列表 | 可见 `platform='GroupA'` + 旧 `teamLeader='leader_a'` |
| T3.27 | Manager 详情-新数据 | leader_a 查 A 组新申请 | 可见 |
| T3.28 | Manager 详情-旧数据 | leader_a 查旧 `teamLeader='leader_a'` | 可见 |
| T3.29 | Manager 详情-他组 | leader_a 查 B 组申请 | 404 |
| T3.30 | Manager 编辑-他组 | leader_a 更新 B 组申请 | 404 |
| **Dashboard** | | | |
| T3.31 | Dashboard 不受影响 | 查看仪表盘 | 不受 cpsVisible 影响 |
| T3.32 | P2 冻结回归 | 订单列表充值渠道 | 与基线一致 |
| **构建** | | | |
| T3.33 | 后端构建 | `pnpm -C suzaku-gaming-server build` | 0 error |

---

### Phase 4：前端表单重构（P4 UI 部分）

**目标**：重构归因申请页面 UI——项目只读、二级联动、截图必填、角色 ID 前端预校验。

#### 4.1 变更清单

| 文件 | 变更 |
|------|------|
| `src/views/Audit/NewAttribution.vue` | 全面重构表单结构 |
| `src/views/Audit/BindingApply.vue` | 详情弹窗兼容新旧数据格式 |
| `src/api/audit.ts` | 新增 `checkRole()` 方法、类型更新 |
| `src/api/user.ts` | `getTeamOptions` 返回类型更新 |

#### 4.2 表单结构

```
┌─────────────────────────────────┐
│ 项目      "海战" [只读文本]      │
│ 角色ID    [输入框+失焦校验]      │
│ 区服ID    [自动填充/手动输入]    │
│ 区服名称  [自动填充/手动输入]    │
│ 角色昵称  [自动填充/手动输入]    │
│ ── 来源更改为 ──                │
│ 组名      [下拉: 按角色隔离]     │
│ 组员编号  [下拉: 联动组名]       │
│ ── 凭证 ──                      │
│ 截图      [上传: 必选3-5张]      │
│ 备注      [文本域]               │
│ [提交] [取消]                    │
└─────────────────────────────────┘
```

**下拉数据隔离**：

| 角色 | 组名 | 组员编号 |
|------|------|---------|
| 管理员 | 所有组 | 选中组的所有编号 |
| 组长 | 锁定为本组 | 本组所有编号 |
| 组员 | 锁定为本组 | 本组所有编号 |

**提交数据结构**（R1——使用现有字段名）：

```json
{
  "project": "warship",
  "roleId": "9000310001001",
  "serverId": 28,
  "serverName": "S28",
  "roleName": "玩家名",
  "platform": "GroupA",
  "teamMember": "A-0001",
  "attachments": ["url1", "url2", "url3"],
  "remark": "备注",
  "applicant": ""
}
```

> `teamLeader` 不传——后端自动回填。`platform`/`teamMember` 是现有 DTO 字段，不触发白名单拦截。

**角色 ID 前端预校验**（提升体验，不替代服务端校验）：

```
输入角色ID → 失焦 → GET /api/audit/role-check/{roleId}
├── 不存在     → 红色提示 + 禁提交
├── 已绑定     → 橙色提示 + 禁提交
└── 可绑定     → 绿色提示 + 自动填充区服/昵称
```

**详情弹窗兼容**：

```typescript
// 展示逻辑（BindingApply.vue 详情）
const displayGroupName = computed(() => {
  const p = apply.platform;
  // 新数据：GroupA → A组；旧数据：iOS/Google → 原值展示
  if (p?.startsWith('Group')) return p.replace('Group', '') + '组';
  return p || '-';
});
```

#### 4.3 闸门

| 编号 | 测试 | 操作 | 预期 |
|------|------|------|------|
| T4.1 | 项目只读 | 打开页面 | 显示"海战"不可编辑 |
| T4.2 | 组名-管理员 | admin 打开 | 下拉含所有组 |
| T4.3 | 组名-组长 | leader_a 打开 | 锁定 A 组 |
| T4.4 | 组名-组员 | A 组组员打开 | 锁定 A 组 |
| T4.5 | 编号联动 | 选 A 组 | 下拉仅含 A 组编号 |
| T4.6 | 角色ID-有效 | 输入有效 ID 失焦 | 绿色 + 自动填充 |
| T4.7 | 角色ID-无效 | 输入无效 ID 失焦 | 红色 + 禁提交 |
| T4.8 | 角色ID-已绑定 | 输入已绑定 ID 失焦 | 橙色 + 禁提交 |
| T4.9 | 截图 < 3 | 上传 2 张点提交 | 前端阻止 |
| T4.10 | 截图 3 张 | 提交 | 成功 |
| T4.11 | 截图 > 5 | 上传第 6 张 | 拦截 |
| T4.12 | 完整流程 | 全字段提交 | 成功 |
| T4.13 | 存储验证 | 查 DB | `platform`=组编码, `team_member`=编号, `team_leader`=组长用户名, `project`=warship |
| T4.14 | 详情-新记录 | 查看新申请 | 正确展示"A组"/"A-0001" |
| T4.15 | 详情-旧记录 | 查看旧申请 | 展示旧值"iOS"/"组长名" |
| T4.16 | 前端构建 | `type-check && build` | 0 error |
| T4.17 | P2 冻结回归 | 订单列表 | 与基线一致 |

---

### Phase 5：端到端回归验证

**目标**：全链路回归 + 并发场景 + 安全边界，确保无交叉破坏。

| 编号 | 测试 | 操作 | 预期 |
|------|------|------|------|
| T5.1 | E2E 全流程 | 同步 → 申请 → 审核 → 列表展示 | 正确流转 |
| T5.2 | 多组并行 | A/B 组各提交、各审核 | 各自角色独立可见 |
| T5.3 | 金额端到端 | 角色 N 笔订单 | 列表金额 = SUM |
| T5.4 | 权限端到端 | 管理员/组长/组员各功能 | 各权限正确 |
| T5.5 | P2 最终回归 | 订单列表充值渠道 | 与 Phase 0 基线一致 |
| T5.6 | 导出端到端 | 角色/订单/申请各导出 | 格式和内容正确 |
| T5.7 | 分页+排序 | 列表翻页排序 | 正常 |
| T5.8 | 多条件筛选 | 组合筛选 | 正确 |
| T5.9 | CPS 日志同步 | 充值/登录同步 | 不受影响 |
| T5.10 | Dashboard | 查看仪表盘 | 不受 cpsVisible 影响 |
| T5.11 | **安全边界** | 篡改请求绕过前端直接调 API | 后端拒绝非法请求 |
| T5.12 | **并发审核** | 两人同时审核同一申请 | 仅 1 人成功，另 1 人收到"已审核"提示 |

---

## 9. 数据迁移策略

### 9.1 历史角色可见性回填（R8 修正版）

```sql
-- 基于已审核通过的申请回填，取最新一条审核通过记录
-- 排序保证确定性：review_time → apply_time → id（均 DESC），避免 NULL 或并列导致结果不稳定
WITH latest_approved AS (
  SELECT DISTINCT ON (role_id)
    role_id,
    platform
  FROM binding_applies
  WHERE status = 'approved'
  ORDER BY role_id, review_time DESC NULLS LAST, apply_time DESC NULLS LAST, id DESC
)
UPDATE roles r
SET cps_visible = true,
    cps_group = CASE
      -- 仅当 platform 以 'Group' 开头时视为新语义，写入 cps_group
      WHEN la.platform LIKE 'Group%' THEN la.platform
      -- 旧语义（iOS/Google 等）：保留角色已有 cps_group，绝不写入旧平台值
      ELSE r.cps_group   -- 保持原值（可能为 NULL），不做 COALESCE
    END
FROM latest_approved la
WHERE la.role_id = r.role_id
  AND r.cps_visible = false;
```

**说明**：
1. `DISTINCT ON (role_id)` 解决同一角色多条 approved 的非确定性问题。
2. `CASE` 区分新旧 `platform` 语义：新语义（`Group*`）写入 `cps_group`；旧语义保留原值不覆盖，**不使用 `COALESCE`** 防止旧渠道值（iOS/Google）污染 `cps_group`。
3. 此脚本幂等——已 `cps_visible = true` 的不重复处理。
4. 旧语义记录的 `cps_group` 可能仍为 NULL，仅设 `cps_visible = true` 使其可见。业务上这类历史数据展示时可按"未分组"处理。

### 9.2 历史组员编号回填（可执行版）

```typescript
// 独立脚本 scripts/backfill-member-codes.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function backfill() {
  // 查找所有无编号的组员
  const members = await prisma.adminUser.findMany({
    where: { role: 'operator', memberCode: null, cpsGroupCode: { not: null } },
    orderBy: [{ cpsGroupCode: 'asc' }, { createdAt: 'asc' }],
  });

  for (const member of members) {
    const prefix = member.cpsGroupCode!.replace('Group', '');
    // 使用原始 SQL 按数值排序取最大编号（避免字符串排序错误）
    const result = await prisma.$queryRaw<{ max_seq: number }[]>`
      SELECT COALESCE(MAX(CAST(SPLIT_PART(member_code, '-', 2) AS INTEGER)), 0) AS max_seq
      FROM admin_users WHERE cps_group_code = ${member.cpsGroupCode!}
        AND member_code IS NOT NULL AND role = 'operator'
    `;
    const nextSeq = (result[0]?.max_seq || 0) + 1;

    const code = `${prefix}-${String(nextSeq).padStart(4, '0')}`;

    await prisma.adminUser.update({
      where: { id: member.id },
      data: { memberCode: code },
    });
    console.log(`Assigned ${code} to user ${member.username}`);
  }
}

backfill()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

### 9.3 回滚策略（R7 修正版）

| Phase | 回滚方式 |
|-------|---------|
| 通用 | **每阶段开始前 `pg_dump -Fc -f backup_phaseN.dump`**；回滚 = `pg_restore` + git checkout 至该阶段前 commit |
| Phase 1 | 恢复备份；或手动 `ALTER TABLE admin_users DROP CONSTRAINT IF EXISTS group_member_unique, DROP COLUMN IF EXISTS member_code; ALTER TABLE roles DROP COLUMN IF EXISTS cps_visible; DROP INDEX IF EXISTS binding_apply_role_active_unique;` |
| Phase 2 | git 还原 `thinkingdata.service.ts`、`player.service.ts` |
| Phase 3 | git 还原 `audit.service.ts`、`audit.controller.ts`、DTO；SQL 清除联动数据 `UPDATE roles SET cps_visible = false WHERE cps_bind_time > '回滚时间点'` |
| Phase 4 | git 还原前端文件 |
| Phase 5 | 无额外变更 |

---

## 10. 变更文件总清单

### 后端

| 文件 | Phase | 变更类型 |
|------|-------|---------|
| `prisma/schema.prisma` | 1 | 新增字段 + 约束 + 索引 |
| `prisma/seed.ts` | 1 | 重写 |
| `src/modules/user/user.service.ts` | 1 | 修改 |
| `src/modules/user/user.controller.ts` | 1 | 修改 |
| `src/modules/audit/dto/create-binding-apply.dto.ts` | 3 | 修改 |
| `src/modules/audit/dto/update-binding-apply.dto.ts` | 1 | **新建** |
| `src/modules/audit/audit.service.ts` | 3 | 重构 |
| `src/modules/audit/audit.controller.ts` | 3 | 修改 |
| `src/modules/thinkingdata/thinkingdata.service.ts` | 2 | 修改 |
| `src/modules/player/player.service.ts` | 2+3 | 修改 |

### 前端

| 文件 | Phase | 变更类型 |
|------|-------|---------|
| `src/views/Audit/NewAttribution.vue` | 4 | 重构 |
| `src/views/Audit/BindingApply.vue` | 4 | 修改（详情兼容） |
| `src/views/System/UserManagement.vue` | 1 | 修改 |
| `src/api/audit.ts` | 4 | 修改 |
| `src/api/user.ts` | 1 | 修改 |

### 不改动的文件

| 文件 | 原因 |
|------|------|
| `src/modules/cps/cps.service.ts` | 保持 CPS 模块独立（R6） |
| `src/modules/cps/cps-sync.service.ts` | 已正确实现 CPS 维度表过滤 |
| `src/modules/dashboard/dashboard.service.ts` | 统计口径独立于 cpsVisible |

### 新增文件

| 文件 | Phase | 说明 |
|------|-------|------|
| `src/modules/audit/dto/update-binding-apply.dto.ts` | 1 | 更新接口 DTO（R9） |
| `scripts/backfill-member-codes.ts` | 迁移 | 历史编号回填脚本 |

---

## 附录 A：阶段推进硬规则

1. 每阶段闸门**全部通过**后方可进入下一阶段。
2. 每阶段结束后执行 **P2 冻结项回归**。
3. 每阶段开始前执行 **`pg_dump` 数据库备份**。
4. 每阶段完成后执行 **后端 `pnpm -C suzaku-gaming-server build`** 和 **前端 `pnpm -C suzaku-gaming-admin type-check && pnpm -C suzaku-gaming-admin build`**（如涉及）确认构建通过。所有命令均从**仓库根目录**执行，使用 `-C` 指定子项目路径。
5. Phase 1 的 T1.9（并发压测）和 Phase 5 的 T5.12（并发审核）为**必过项**，不可跳过。

## 附录 B：测试分层要求

| 层级 | 工具 | 覆盖范围 |
|------|------|---------|
| 数据库层 | SQL 查询 / Prisma Studio | Schema 约束、索引、默认值 |
| 服务层 | **API 集成测试**（`supertest` + Jest） | 业务规则、权限、校验、事务一致性 |
| 接口层 | HTTP 请求（Postman/curl/脚本） | 端到端 API 行为 |
| 前端层 | 手动验证 + 升级 E2E（Playwright） | UI 交互、表单校验 |

> 现有 E2E 测试（`new-attribution.spec.ts`、`binding-apply.spec.ts` 等）仅覆盖"页面存在性"断言，不保障业务正确性。建议在 Phase 4 后逐步升级为包含登录 → 操作 → 断言的完整 E2E 场景。

**R22 前置**：仓库当前缺少 `suzaku-gaming-server/test/jest-e2e.json`（`package.json:20` 的 `test:e2e` 脚本引用）。Phase 0 步骤 0.3 需创建以下两个文件，否则 API 集成测试无法运行。

**文件 1：`suzaku-gaming-server/test/jest-e2e.json`**

```json
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": { "^.+\\.(t|j)s$": "ts-jest" }
}
```

**文件 2：`suzaku-gaming-server/test/app.e2e-spec.ts`**（最小可跑通模板）

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    // 与 main.ts 保持一致的全局管道配置
    app.useGlobalPipes(
      new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true }),
    );
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  it('/ (GET) health check or root should respond', async () => {
    // 根据实际路由调整；至少验证应用能启动并响应
    const res = await request(app.getHttpServer()).get('/');
    expect([200, 404]).toContain(res.status); // 有或无根路由均可
  });

  it('/api/auth/profile (GET) without token should return 401', async () => {
    // 当前后端受保护接口为 /api/auth/profile（auth.controller.ts:26）
    const res = await request(app.getHttpServer()).get('/api/auth/profile');
    expect(res.status).toBe(401);
  });
});
```

> **启动方式约束**：运行 `pnpm -C suzaku-gaming-server test:e2e` 即可。该命令引用 `package.json` 中配置的 `jest --config ./test/jest-e2e.json`。执行前需确保测试数据库可连接（使用 `.env.test` 或环境变量覆盖 `DATABASE_URL`），且已完成 `prisma db push`。T0.3 闸门标准：**上述两个用例全部通过**。

---

> **文档终止** — 按 Phase 0 → 1 → 2 → 3 → 4 → 5 顺序执行。
